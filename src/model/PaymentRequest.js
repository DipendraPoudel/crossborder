/**
 * Crossborder
 * MasterCard Cross-Border Services enables banks in their capacity as Originating Institutions to send cross-border payments for various payment types including person-to-person payments (P2P), person-to-business payments (P2B), business-to-person disbursements (B2P), business-to-business payments (B2B), and government-to-person disbursement (G2P). Mastercard Cross-Border Services supports a variety of payout options, including bank accounts, mobile money accounts, consumer cards, and retail cash pick-up.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: apisupport@mastercard.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */

import ApiClient from '../ApiClient';
import AdditionalData from './AdditionalData';
import FxType from './FxType';
import PaymentAmount from './PaymentAmount';
import Recipient from './Recipient';
import Sender from './Sender';

/**
 * The PaymentRequest model module.
 * @module model/PaymentRequest
 * @version 1.0.0
 */
class PaymentRequest {
    /**
     * Constructs a new <code>PaymentRequest</code>.
     * Contains the details of the request message.
     * @alias module:model/PaymentRequest
     * @param transactionReference {String} This parameter contains the client-provided unique reference number of the transaction. The string held must be unique per transaction. Note that when utilizing a quote, this parameter's value must be identical to the value created for the associated quote.  It holds a string of alphanumeric special characters with a maximum length of 40 and a minimum length of 1.
     */
    constructor(transactionReference) { 
        
        PaymentRequest.initialize(this, transactionReference);
    }

    /**
     * Initializes the fields of this object.
     * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
     * Only for internal use.
     */
    static initialize(obj, transactionReference) { 
        obj['transaction_reference'] = transactionReference;
    }

    /**
     * Constructs a <code>PaymentRequest</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/PaymentRequest} obj Optional instance to populate.
     * @return {module:model/PaymentRequest} The populated <code>PaymentRequest</code> instance.
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new PaymentRequest();

            if (data.hasOwnProperty('transaction_reference')) {
                obj['transaction_reference'] = ApiClient.convertToType(data['transaction_reference'], 'String');
            }
            if (data.hasOwnProperty('proposal_id')) {
                obj['proposal_id'] = ApiClient.convertToType(data['proposal_id'], 'String');
            }
            if (data.hasOwnProperty('local_date_time')) {
                obj['local_date_time'] = ApiClient.convertToType(data['local_date_time'], 'String');
            }
            if (data.hasOwnProperty('sender_account_uri')) {
                obj['sender_account_uri'] = ApiClient.convertToType(data['sender_account_uri'], 'String');
            }
            if (data.hasOwnProperty('recipient_account_uri')) {
                obj['recipient_account_uri'] = ApiClient.convertToType(data['recipient_account_uri'], 'String');
            }
            if (data.hasOwnProperty('payment_amount')) {
                obj['payment_amount'] = PaymentAmount.constructFromObject(data['payment_amount']);
            }
            if (data.hasOwnProperty('payment_origination_country')) {
                obj['payment_origination_country'] = ApiClient.convertToType(data['payment_origination_country'], 'String');
            }
            if (data.hasOwnProperty('fx_type')) {
                obj['fx_type'] = FxType.constructFromObject(data['fx_type']);
            }
            if (data.hasOwnProperty('receiving_bank_name')) {
                obj['receiving_bank_name'] = ApiClient.convertToType(data['receiving_bank_name'], 'String');
            }
            if (data.hasOwnProperty('receiving_bank_branch_name')) {
                obj['receiving_bank_branch_name'] = ApiClient.convertToType(data['receiving_bank_branch_name'], 'String');
            }
            if (data.hasOwnProperty('bank_code')) {
                obj['bank_code'] = ApiClient.convertToType(data['bank_code'], 'String');
            }
            if (data.hasOwnProperty('payment_type')) {
                obj['payment_type'] = ApiClient.convertToType(data['payment_type'], 'String');
            }
            if (data.hasOwnProperty('source_of_income')) {
                obj['source_of_income'] = ApiClient.convertToType(data['source_of_income'], 'String');
            }
            if (data.hasOwnProperty('sender')) {
                obj['sender'] = Sender.constructFromObject(data['sender']);
            }
            if (data.hasOwnProperty('recipient')) {
                obj['recipient'] = Recipient.constructFromObject(data['recipient']);
            }
            if (data.hasOwnProperty('purpose_of_payment')) {
                obj['purpose_of_payment'] = ApiClient.convertToType(data['purpose_of_payment'], 'String');
            }
            if (data.hasOwnProperty('payment_file_identifier')) {
                obj['payment_file_identifier'] = ApiClient.convertToType(data['payment_file_identifier'], 'String');
            }
            if (data.hasOwnProperty('card_rate_id')) {
                obj['card_rate_id'] = ApiClient.convertToType(data['card_rate_id'], 'String');
            }
            if (data.hasOwnProperty('additional_data')) {
                obj['additional_data'] = AdditionalData.constructFromObject(data['additional_data']);
            }
        }
        return obj;
    }

    /**
     * Validates the JSON data with respect to <code>PaymentRequest</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>PaymentRequest</code>.
     */
    static validateJSON(data) {
        // check to make sure all required properties are present in the JSON string
        for (const property of PaymentRequest.RequiredProperties) {
            if (!data[property]) {
                throw new Error("The required field `" + property + "` is not found in the JSON data: " + JSON.stringify(data));
            }
        }
        // ensure the json data is a string
        if (data['transaction_reference'] && !(typeof data['transaction_reference'] === 'string' || data['transaction_reference'] instanceof String)) {
            throw new Error("Expected the field `transaction_reference` to be a primitive type in the JSON string but got " + data['transaction_reference']);
        }
        // ensure the json data is a string
        if (data['proposal_id'] && !(typeof data['proposal_id'] === 'string' || data['proposal_id'] instanceof String)) {
            throw new Error("Expected the field `proposal_id` to be a primitive type in the JSON string but got " + data['proposal_id']);
        }
        // ensure the json data is a string
        if (data['local_date_time'] && !(typeof data['local_date_time'] === 'string' || data['local_date_time'] instanceof String)) {
            throw new Error("Expected the field `local_date_time` to be a primitive type in the JSON string but got " + data['local_date_time']);
        }
        // ensure the json data is a string
        if (data['sender_account_uri'] && !(typeof data['sender_account_uri'] === 'string' || data['sender_account_uri'] instanceof String)) {
            throw new Error("Expected the field `sender_account_uri` to be a primitive type in the JSON string but got " + data['sender_account_uri']);
        }
        // ensure the json data is a string
        if (data['recipient_account_uri'] && !(typeof data['recipient_account_uri'] === 'string' || data['recipient_account_uri'] instanceof String)) {
            throw new Error("Expected the field `recipient_account_uri` to be a primitive type in the JSON string but got " + data['recipient_account_uri']);
        }
        // validate the optional field `payment_amount`
        if (data['payment_amount']) { // data not null
          PaymentAmount.validateJSON(data['payment_amount']);
        }
        // ensure the json data is a string
        if (data['payment_origination_country'] && !(typeof data['payment_origination_country'] === 'string' || data['payment_origination_country'] instanceof String)) {
            throw new Error("Expected the field `payment_origination_country` to be a primitive type in the JSON string but got " + data['payment_origination_country']);
        }
        // validate the optional field `fx_type`
        if (data['fx_type']) { // data not null
          FxType.validateJSON(data['fx_type']);
        }
        // ensure the json data is a string
        if (data['receiving_bank_name'] && !(typeof data['receiving_bank_name'] === 'string' || data['receiving_bank_name'] instanceof String)) {
            throw new Error("Expected the field `receiving_bank_name` to be a primitive type in the JSON string but got " + data['receiving_bank_name']);
        }
        // ensure the json data is a string
        if (data['receiving_bank_branch_name'] && !(typeof data['receiving_bank_branch_name'] === 'string' || data['receiving_bank_branch_name'] instanceof String)) {
            throw new Error("Expected the field `receiving_bank_branch_name` to be a primitive type in the JSON string but got " + data['receiving_bank_branch_name']);
        }
        // ensure the json data is a string
        if (data['bank_code'] && !(typeof data['bank_code'] === 'string' || data['bank_code'] instanceof String)) {
            throw new Error("Expected the field `bank_code` to be a primitive type in the JSON string but got " + data['bank_code']);
        }
        // ensure the json data is a string
        if (data['payment_type'] && !(typeof data['payment_type'] === 'string' || data['payment_type'] instanceof String)) {
            throw new Error("Expected the field `payment_type` to be a primitive type in the JSON string but got " + data['payment_type']);
        }
        // ensure the json data is a string
        if (data['source_of_income'] && !(typeof data['source_of_income'] === 'string' || data['source_of_income'] instanceof String)) {
            throw new Error("Expected the field `source_of_income` to be a primitive type in the JSON string but got " + data['source_of_income']);
        }
        // validate the optional field `sender`
        if (data['sender']) { // data not null
          Sender.validateJSON(data['sender']);
        }
        // validate the optional field `recipient`
        if (data['recipient']) { // data not null
          Recipient.validateJSON(data['recipient']);
        }
        // ensure the json data is a string
        if (data['purpose_of_payment'] && !(typeof data['purpose_of_payment'] === 'string' || data['purpose_of_payment'] instanceof String)) {
            throw new Error("Expected the field `purpose_of_payment` to be a primitive type in the JSON string but got " + data['purpose_of_payment']);
        }
        // ensure the json data is a string
        if (data['payment_file_identifier'] && !(typeof data['payment_file_identifier'] === 'string' || data['payment_file_identifier'] instanceof String)) {
            throw new Error("Expected the field `payment_file_identifier` to be a primitive type in the JSON string but got " + data['payment_file_identifier']);
        }
        // ensure the json data is a string
        if (data['card_rate_id'] && !(typeof data['card_rate_id'] === 'string' || data['card_rate_id'] instanceof String)) {
            throw new Error("Expected the field `card_rate_id` to be a primitive type in the JSON string but got " + data['card_rate_id']);
        }
        // validate the optional field `additional_data`
        if (data['additional_data']) { // data not null
          AdditionalData.validateJSON(data['additional_data']);
        }

        return true;
    }


}

PaymentRequest.RequiredProperties = ["transaction_reference"];

/**
 * This parameter contains the client-provided unique reference number of the transaction. The string held must be unique per transaction. Note that when utilizing a quote, this parameter's value must be identical to the value created for the associated quote.  It holds a string of alphanumeric special characters with a maximum length of 40 and a minimum length of 1.
 * @member {String} transaction_reference
 */
PaymentRequest.prototype['transaction_reference'] = undefined;

/**
 * This parameter contains the system generated ID of the proposal to execute for this payment. This field is returned in the Quote service.  Note: For these payments, the following fields filled in the quote do not need to be provided again the payment; but if they are, they will process without error as long as the data matches what was sent in the Quote that generated the proposal ID.  An exception is for the bank_code field.  If bank_code was provided in the the quote and provided again in the payment, then the newly provided value will be used. If using a proposal_id and the bank_code was provided in the quote, then that value will be automatically copied into the payment.    paymentrequest.sender_account_uri  paymentrequest.recipient_account_uri  paymentrequest.payment_amount  paymentrequest.payment_amount.amount  paymentrequest.payment_amount.currency  paymentrequest.payment_origination_country  paymentrequest.fx_type  paymentrequest.fx_type.forward  paymentrequest.fx_type.forward.receiver_currency  paymentrequest.fx_type.forward.fees_included  paymentrequest.fx_type.reverse  paymentrequest.fx_type.reverse.sender_currency  paymentrequest.bank_code  paymentrequest.payment_type  paymentrequest.card_rate_id  It is a conditional parameter that holds a string of alphanumeric special characters with a maximum length of 30 and a minimum length of 0.
 * @member {String} proposal_id
 */
PaymentRequest.prototype['proposal_id'] = undefined;

/**
 * This parameter contains the local date for the location where the payment is originating. Note that it is required when the recipient_account_uri = pan.It is a conditional parameter that holds a numeric value of the format MMDDHHMMSS.
 * @member {String} local_date_time
 */
PaymentRequest.prototype['local_date_time'] = undefined;

/**
 * For all transactions, including nested payments, the Sender Account URI scheme is a mandatory parameter based on the account that is initiating the transaction and must contain the ultimate sender's unique account details for the actual mobile wallet, ewallet, account identifier, bank account or card that is initiating the transaction.  Accordingly, this field should not include a blanket or general account managed by the Debtor Agent.  It is a conditional parameter that holds alphanumeric special characters with a maximum length of 200 and a minimum length of 1.  Note: You do not provide this parameter if using a proposal_id because this Quote details will carry over. If you are not using a proposal_id, this field is required at the time of the payment request.
 * @member {String} sender_account_uri
 */
PaymentRequest.prototype['sender_account_uri'] = undefined;

/**
 * This parameter contains the URI identifying the beneficiary's account to receive the payment.  Note that you would not provide this if proposal_id was provided because the data will be based on the quote provided. If not utilizing proposal_id , this field is required at the time of the payment request. When using the \"pan\" scheme, the \"exp\" property is optional.  It is a conditional parameter that holds alphanumeric special characters with a maximum length of 200 and a minimum length of 1. Refer to the \"Recipient Account URI\" section on \"Additional Resources\" page for details about scheme specific data.
 * @member {String} recipient_account_uri
 */
PaymentRequest.prototype['recipient_account_uri'] = undefined;

/**
 * @member {module:model/PaymentAmount} payment_amount
 */
PaymentRequest.prototype['payment_amount'] = undefined;

/**
 * This parameter contains the three-letter \"ISO 3166-1 alpha-3\" country code representing the country in which the payment is being initiated.  Note that you would not provide this if proposal_id was provided because the data will be based on the quote provided. If not utilizing proposal_id, this field is required at the time of the payment request.  It holds a string of alphabet characters with an exact length of three.
 * @member {String} payment_origination_country
 */
PaymentRequest.prototype['payment_origination_country'] = undefined;

/**
 * @member {module:model/FxType} fx_type
 */
PaymentRequest.prototype['fx_type'] = undefined;

/**
 * Name of the Bank holding the receiving account. This is required only for specific bank service provider end points identified as part of corridor data details.  It is a conditional parameter that contains a string of alphanumeric special characters with a maximum length of 140 and a minimum length of 1.
 * @member {String} receiving_bank_name
 */
PaymentRequest.prototype['receiving_bank_name'] = undefined;

/**
 * Name of the Bank Branch holding the receiving account. This is required only for specific bank service provider end points identified as part of corridor data details.  It is a conditional parameter that contains a string of alphanumeric special characters with a maximum length of 140 and a minimum length of 1.
 * @member {String} receiving_bank_branch_name
 */
PaymentRequest.prototype['receiving_bank_branch_name'] = undefined;

/**
 * This parameter contains a bank code associated with the bank name and bank identification code (BIC) provided by the customer. It is required only for specific bank service provider endpoints identified as part of corridor data details.  Note that if you provided this in the quote and provide again here, then the newly provided value will be used. If using a proposal_id and the bank_code was provided in the quote, then that value will be automatically copied here for you.  It is a conditional parameter that holds a string of alphanumeric special characters with a maximum length of 225 and a minimum length of 1.
 * @member {String} bank_code
 */
PaymentRequest.prototype['bank_code'] = undefined;

/**
 * This parameter contains a three-digit code for the type of transaction that is being submitted.  Note that you would not provide this if proposal_id was provided because the data will be based on the quote provided. If not utilizing proposal_id, this field is required at the time of the payment request.  Available types and their uses are:  B2P: Business Disbursement to Person - A disbursement of funds from a business to an individual account.  B2B: Business to Business- A transfer of funds from one business to another.  G2P: Government to Person - A disbursement of funds from a government agency to a private individual person's account  P2P: Person to Person - A transfer of funds from one private individual person's account to another private individual person's account.  P2B: Person to Business - A payment by an individual person to a business.  It is a conditional parameter that holds a string of alphabet characters with an exact length of three.
 * @member {String} payment_type
 */
PaymentRequest.prototype['payment_type'] = undefined;

/**
 * Sender's identification of the source of the funds being submitted. Required only for specific receiving service provider end points identified as part of corridor data details. Valid values will be provided during onboarding.  It is a conditional parameter that contains a string of alphanumeric special characters with a maximum length of 35 and a minimum length of 1.
 * @member {String} source_of_income
 */
PaymentRequest.prototype['source_of_income'] = undefined;

/**
 * @member {module:model/Sender} sender
 */
PaymentRequest.prototype['sender'] = undefined;

/**
 * @member {module:model/Recipient} recipient
 */
PaymentRequest.prototype['recipient'] = undefined;

/**
 * This parameter contains the purpose of payment. Note that it is required for specific receiving service provider end points identified as part of corridor data details.  Valid Values: Family Maintenance, Household Maintenance, Donation or Gifts, Payment of Loan, Purchase of Property, Funeral Expenses, Medical Expenses, Wedding Expenses, Payment of bills, Education, Savings, Employee Colleague, Business/Investment, Salary, Payment of goods and services .  It is a conditional parameter that holds a string of alphanumeric special characters with a maximum length of 39 and a minimum length of 1.
 * @member {String} purpose_of_payment
 */
PaymentRequest.prototype['purpose_of_payment'] = undefined;

/**
 * This parameter identifies the payment file in which this specific payment was submitted by the originator.  Note that it is required if the payment was generated via a batch payment file. It will be blank if wasn't generated via a batch payment file.  It is conditional and holds a string of alphanumeric special characters with a maximum length of 35 and a minimum length of 1. 
 * @member {String} payment_file_identifier
 */
PaymentRequest.prototype['payment_file_identifier'] = undefined;

/**
 * This Parameter contains the System generated Rate ID associated with a currency pair that will be used in a transaction. This ID will be included by the OI in the Payment request and provided to the OI in the Rate File / API for those customers configured to receive this rate information. Note this value must not be provided if a proposal_id is being used in the payment because the rate applied to the payment will be based on the quote provided.  It is an optional parameter that holds a string of alphanumeric special characters with a maximum length of 35 and a minimum length of 1.
 * @member {String} card_rate_id
 */
PaymentRequest.prototype['card_rate_id'] = undefined;

/**
 * @member {module:model/AdditionalData} additional_data
 */
PaymentRequest.prototype['additional_data'] = undefined;






export default PaymentRequest;

